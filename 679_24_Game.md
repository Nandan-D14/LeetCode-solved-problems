# 🎮 24 Game - LeetCode Solution

## 📌 Problem
You are given 4 cards, each with a number in the range [1, 9].  
Determine if you can arrange them with the operators `+ - * /` and parentheses `()` to form an expression equal to **24**.

---

## ✅ Examples
### Example 1
Input: `cards = [4,1,8,7]`  
Output: `true`  
Explanation: `(8 - 4) * (7 - 1) = 24`

### Example 2
Input: `cards = [1,2,1,2]`  
Output: `false`

---

## ⚡ Approach
- Use **backtracking** to try all possible operations.
- Pick two numbers, apply an operator, and replace them with the result.
- Continue recursively until only one number remains.
- If that number is close to **24 (floating precision check)** → return true.

---


## 📝 Problem Understanding

You are given **4 cards**, each with a number from **1 to 9**.
You must check if you can arrange these numbers with the operators `+ - * /` and parentheses `()` to form an expression that **equals 24**.

### Key Rules:

1. Division is **real division** (not integer division).
2. All operations are between **two numbers only**.
3. No concatenation (e.g., `1` and `2` → `12` is invalid).
4. No unary `-` (so no standalone negative signs).

---

## ✅ Example Walkthrough

**Example 1:**
`cards = [4,1,8,7]`
We can do:
$(8 - 4) * (7 - 1) = 4 * 6 = 24$
So output is **true** ✅

**Example 2:**
`cards = [1,2,1,2]`
No possible operations lead to 24.
So output is **false** ❌

---

## ⚡ Solution Idea

We solve this with **backtracking**:

1. Pick any two numbers from the list.
2. Apply each operation (`+ - * /`) on them.
3. Replace the two numbers with the result and continue with the remaining list.
4. Repeat until only one number is left.
5. If that number is **close to 24 (within floating-point tolerance)** → return true.

This explores **all permutations and operations**.

---

## 💻 Java Solution

```java
// java
class Solution {
    private static final double EPSILON = 1e-6;

    public boolean judgePoint24(int[] cards) {
        List<Double> nums = new ArrayList<>();
        for (int card : cards) nums.add((double) card);
        return solve(nums);
    }

    private boolean solve(List<Double> nums) {
        if (nums.size() == 1) {
            return Math.abs(nums.get(0) - 24) < EPSILON;
        }

        for (int i = 0; i < nums.size(); i++) {
            for (int j = 0; j < nums.size(); j++) {
                if (i != j) {
                    List<Double> next = new ArrayList<>();
                    for (int k = 0; k < nums.size(); k++) {
                        if (k != i && k != j) next.add(nums.get(k));
                    }

                    for (double val : compute(nums.get(i), nums.get(j))) {
                        next.add(val);
                        if (solve(next)) return true;
                        next.remove(next.size() - 1);
                    }
                }
            }
        }
        return false;
    }

    private List<Double> compute(double a, double b) {
        List<Double> results = new ArrayList<>();
        results.add(a + b);
        results.add(a - b);
        results.add(b - a);
        results.add(a * b);
        if (Math.abs(b) > EPSILON) results.add(a / b);
        if (Math.abs(a) > EPSILON) results.add(b / a);
        return results;
    }
}
````

---

## 🧠 Complexity

* **Time:** Exponential (since we try all combinations & operations).
* **Space:** O(1) extra (only recursion stack + list).

---

## 🎯 Topics

* Backtracking
* Recursion
* Math


